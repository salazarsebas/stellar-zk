//! Project and backend configuration types.
//!
//! stellar-zk uses two JSON config files per project:
//!
//! - **`stellar-zk.config.json`** ([`ProjectConfig`]) — project-level settings: name, backend
//!   choice, profile, circuit entry point, contract paths, deploy target. Generated by `init`,
//!   read by all other commands.
//!
//! - **`backend.config.json`** ([`BackendConfig`]) — backend-specific parameters: curve, trusted
//!   setup path, circuit power (Groth16), oracle hash (UltraHonk), guest target (RISC Zero).
//!   Only the variant matching the chosen backend is populated; the rest are `None`.
//!
//! Both files are created by `stellar-zk init` and loaded from the project root by subsequent
//! commands via [`crate::project::load_project`].

use std::path::{Path, PathBuf};

use serde::{Deserialize, Serialize};

use crate::error::{Result, StellarZkError};

/// Project-level configuration (stellar-zk.config.json).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectConfig {
    pub version: String,
    pub project_name: String,
    pub backend: String,
    pub profile: String,
    pub circuit: CircuitConfig,
    pub contract: ContractConfig,
    pub deploy: DeployConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CircuitConfig {
    pub entry_point: PathBuf,
    pub input_file: PathBuf,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContractConfig {
    pub name: String,
    pub source_dir: PathBuf,
    pub wasm_output: PathBuf,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeployConfig {
    pub network: String,
    pub source_identity: String,
}

/// Backend-specific configuration (backend.config.json).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BackendConfig {
    pub backend: String,
    #[serde(default)]
    pub groth16: Option<Groth16Config>,
    #[serde(default)]
    pub ultrahonk: Option<UltraHonkConfig>,
    #[serde(default)]
    pub risc0: Option<Risc0Config>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Groth16Config {
    pub curve: String,
    pub trusted_setup: Option<String>,
    pub circuit_power: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UltraHonkConfig {
    pub oracle_hash: String,
    pub recursive: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Risc0Config {
    pub guest_target: String,
    pub segment_limit_po2: u32,
    pub groth16_wrap: bool,
}

impl ProjectConfig {
    pub fn load(path: &Path) -> Result<Self> {
        let contents =
            std::fs::read_to_string(path).map_err(|e| StellarZkError::ConfigNotFound {
                path: path.to_path_buf(),
                source: e,
            })?;
        serde_json::from_str(&contents).map_err(|e| StellarZkError::ConfigParse {
            path: path.to_path_buf(),
            source: e,
        })
    }

    pub fn save(&self, path: &Path) -> Result<()> {
        let contents =
            serde_json::to_string_pretty(self).map_err(|e| StellarZkError::ConfigParse {
                path: path.to_path_buf(),
                source: e,
            })?;
        std::fs::write(path, contents)?;
        Ok(())
    }

    pub fn default_for_backend(project_name: &str, backend: &str) -> Self {
        let (entry_point, contract_name) = match backend {
            "groth16" => ("circuits/main.circom", "groth16_verifier"),
            "ultrahonk" => ("circuits/src/main.nr", "ultrahonk_verifier"),
            "risc0" => ("programs/guest/src/main.rs", "risc0_verifier"),
            _ => ("circuits/main", "verifier"),
        };

        Self {
            version: "0.1.0".into(),
            project_name: project_name.into(),
            backend: backend.into(),
            profile: "development".into(),
            circuit: CircuitConfig {
                entry_point: PathBuf::from(entry_point),
                input_file: PathBuf::from("inputs/input.json"),
            },
            contract: ContractConfig {
                name: contract_name.into(),
                source_dir: PathBuf::from("contracts/verifier"),
                wasm_output: PathBuf::from(format!(
                    "target/wasm32v1-none/release/{contract_name}.wasm"
                )),
            },
            deploy: DeployConfig {
                network: "testnet".into(),
                source_identity: "default".into(),
            },
        }
    }
}

impl BackendConfig {
    pub fn load(path: &Path) -> Result<Self> {
        let contents =
            std::fs::read_to_string(path).map_err(|e| StellarZkError::ConfigNotFound {
                path: path.to_path_buf(),
                source: e,
            })?;
        serde_json::from_str(&contents).map_err(|e| StellarZkError::ConfigParse {
            path: path.to_path_buf(),
            source: e,
        })
    }

    pub fn save(&self, path: &Path) -> Result<()> {
        let contents =
            serde_json::to_string_pretty(self).map_err(|e| StellarZkError::ConfigParse {
                path: path.to_path_buf(),
                source: e,
            })?;
        std::fs::write(path, contents)?;
        Ok(())
    }

    pub fn default_for_backend(backend: &str) -> Self {
        Self {
            backend: backend.into(),
            groth16: if backend == "groth16" {
                Some(Groth16Config {
                    curve: "bn254".into(),
                    trusted_setup: None,
                    circuit_power: 14,
                })
            } else {
                None
            },
            ultrahonk: if backend == "ultrahonk" {
                Some(UltraHonkConfig {
                    oracle_hash: "keccak".into(),
                    recursive: false,
                })
            } else {
                None
            },
            risc0: if backend == "risc0" {
                Some(Risc0Config {
                    guest_target: "riscv32im-risc0-zkvm-elf".into(),
                    segment_limit_po2: 20,
                    groth16_wrap: true,
                })
            } else {
                None
            },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_project_config_roundtrip() {
        let dir = tempfile::tempdir().unwrap();
        let path = dir.path().join("stellar-zk.config.json");
        let config = ProjectConfig::default_for_backend("testproj", "groth16");
        config.save(&path).unwrap();
        let loaded = ProjectConfig::load(&path).unwrap();
        assert_eq!(loaded.project_name, "testproj");
        assert_eq!(loaded.backend, "groth16");
        assert_eq!(loaded.profile, "development");
    }

    #[test]
    fn test_backend_config_roundtrip_groth16() {
        let dir = tempfile::tempdir().unwrap();
        let path = dir.path().join("backend.config.json");
        let config = BackendConfig::default_for_backend("groth16");
        config.save(&path).unwrap();
        let loaded = BackendConfig::load(&path).unwrap();
        assert_eq!(loaded.backend, "groth16");
        let g = loaded.groth16.unwrap();
        assert_eq!(g.curve, "bn254");
        assert_eq!(g.circuit_power, 14);
        assert!(loaded.ultrahonk.is_none());
        assert!(loaded.risc0.is_none());
    }

    #[test]
    fn test_backend_config_roundtrip_ultrahonk() {
        let dir = tempfile::tempdir().unwrap();
        let path = dir.path().join("backend.config.json");
        let config = BackendConfig::default_for_backend("ultrahonk");
        config.save(&path).unwrap();
        let loaded = BackendConfig::load(&path).unwrap();
        let uh = loaded.ultrahonk.unwrap();
        assert_eq!(uh.oracle_hash, "keccak");
        assert!(!uh.recursive);
    }

    #[test]
    fn test_backend_config_roundtrip_risc0() {
        let dir = tempfile::tempdir().unwrap();
        let path = dir.path().join("backend.config.json");
        let config = BackendConfig::default_for_backend("risc0");
        config.save(&path).unwrap();
        let loaded = BackendConfig::load(&path).unwrap();
        let r0 = loaded.risc0.unwrap();
        assert_eq!(r0.guest_target, "riscv32im-risc0-zkvm-elf");
        assert!(r0.groth16_wrap);
    }

    #[test]
    fn test_default_groth16_fields() {
        let cfg = ProjectConfig::default_for_backend("myapp", "groth16");
        assert_eq!(
            cfg.circuit.entry_point,
            PathBuf::from("circuits/main.circom")
        );
        assert_eq!(cfg.contract.name, "groth16_verifier");
    }

    #[test]
    fn test_load_nonexistent_path() {
        let result = ProjectConfig::load(Path::new("/tmp/nonexistent_stellar_zk_cfg.json"));
        assert!(result.is_err());
        let err = result.unwrap_err();
        assert!(matches!(err, StellarZkError::ConfigNotFound { .. }));
    }
}
